/***
 * MIT LICENSED BY -  Denis Power(Inter creator)
 * Typescript declaration file for Inter version 2.2.4
 * Version - 1.0.0
 * Repo - https://github.com/interjs/inter/types
 * GENERATED BY INTER BUILDER
 */

interface backendInterface {
  new (): backendInstance;
}

interface backendInstance {
  request(options: ajaxOptions): ajaxReactorInterface;
}

/***
 * These are the most commonly used HTTP request methods, the others
 * ones are not supported in Ajax request.
 *
 */

type httpRequestMethods =
  | "GET"
  | "POST"
  | "PUT"
  | "HEAD"
  | "DELETE"
  | "OPTIONS"
  | "PATCH";

interface ajaxOptions {
  type: httpRequestMethods;
  path: string;
  headers?: object;
  timeout?: number;
  events?: {
    onprogress?(args: { readonly progress: number; abort(): void }): void;
    onabort?(): void;
    ontimeout?(): void;
  };
  security?: {
    username: string;
    password: string;
  };
  body?: any;
}

type ajaxResponseCallBack = (response: ajaxResponse) => void;
interface ajaxReactorInterface {
  okay(callBack: ajaxResponseCallBack): void;
  error(callBack: ajaxResponseCallBack): void;
  response(
    okayCallBack: ajaxResponseCallBack,
    errorCallBack: ajaxResponseCallBack
  ): void;
}

interface ajaxResponse {
  readonly data: any;
  readonly status: number;
  readonly statusText: string;
  readonly headers: object;
  isObj(): boolean;
}

export declare var Backend: backendInterface;
type refValueType = string | number | null | void;
type refMethods<T> = {
  setRefs?: {
    [ref in keyof T]?: refValueType;
  };
  observe(
    ref: string,
    value: refValueType,
    previousValue: refValueType
  ): boolean;
};

interface refOptionsInterface<T> {
  in: string;
  data: T;
}

export declare function Ref<T extends object>(
  options: refOptionsInterface<T>
): refMethods<T> & T;
type refValueType = boolean;
type renderIfMethods<T> = {
  setConds: {
    [prop in keyof T]?: refValueType;
  };
  observe(ref: keyof T, value: refValueType): boolean;
};

interface renderIfOptionsInterface<T> {
  in: string;
  data: {
    [prop: string]: boolean;
  } & T;
}

export declare function renderIf<T extends object>(
  options: renderIfOptionsInterface<T>
): renderIfMethods<T> & T;
import { templateReturn } from "./template";

interface renderListOptionsInterface<T> {
  in: string;
  each: T;
  optimize?: boolean;
  do: doOptionsType<T>;
}

type universalReactorPropsType<T> = {
  obserseve(callBack: (reactor: T) => void): boolean;
  setEach: eachTypes;
};

interface ArrayReactor<T> extends universalReactorPropsType<T> {
  addItems(items: any[], index?: number): boolean;
}

interface ObjectReactor<T> extends universalReactorPropsType<T> {
  setProps?: T;
}

interface objectProps<T> {
  setProps?: T;
  defineProps?: object;
  deleteProps?: Array<keyof T>;
}

type eachTypes = any[] | Object | Set<any> | Map<any, any> | number;
type PropValueType<T> = T[keyof T];
type doOptionsType<T> = T extends any[]
  ? (
      this: returnReactorType<T>,
      item: Item<T>,
      index: number,
      reactor: T
    ) => templateReturn
  : T extends object
  ? (
      this: returnReactorType<T>,
      prop: string,
      value: PropValueType<T>,
      reactor: returnReactorType<T>
    ) => templateReturn
  : templateReturn;
type Item<T> = T[any] extends object ? T[any] & objectProps<T[any]> : T[any];
type returnReactorType<T> = T extends any[]
  ? Item<T>[] & ArrayReactor<T>
  : T extends object
  ? T & ObjectReactor<T>
  : null;

export declare function renderList<T extends eachTypes>(
  renderListOption: renderListOptionsInterface<T>
): returnReactorType<T>;
type HTMLTags = keyof HTMLElementTagNameMap;
type textTypes = string | number | null | void;
interface templateOptionsInterface {
  tag: HTMLTags | ((this: void) => HTMLTags);
  text?: textTypes | ((this: void) => textTypes);
  renderIf?: boolean;
  events?: {
    [event in keyof GlobalEventHandlers]?: (
      this: Document,
      event: Event
    ) => void;
  };
  attrs?: object;
  styles?: {
    [style in keyof CSSStyleDeclaration]?: CSSStyleDeclaration[style];
  };
  children?: templateOptionsInterface[];
}

export interface templateReturn {
  element: templateOptionsInterface;
}

export declare function template(
  options: templateOptionsInterface
): templateReturn;
type attrType = string | number | null;
type attrs<T> = T[keyof T];
interface toAttrsMethods<T> {
  setAttrs?: T[keyof T];
  observe?(attr: string, value: attrType): boolean;
}

interface toAttrsOptionsInterface<T> {
  in: string;
  data: T;
}

export declare function toAttrs<T extends object>(
  options: toAttrsOptionsInterface<T>
): {
  [prop in keyof T]: toAttrsMethods<T> & T[prop];
};
